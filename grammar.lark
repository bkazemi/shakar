//start: (comment | stmtlist | NEWLINE | _NL)*

start_noindent: _NL* stmtlist (_NL+ stmtlist)* _NL*
start_indented: _NL* stmtlist (_NL+ stmtlist)* _NL*
//start_indented: stmtlist (NEWLINE+ stmtlist)* NEWLINE*

RBRACE: "}"
LBRACE: "{"
RSQB: "]"
LSQB: "["
RPAR: ")"
LPAR: "("
DOT: "."
COMMA: ","
SEMI: ";"
COLON: ":"

AT: "@"

WALRUS: ":="
APPLYASSIGN: ".="

QMARK: "?"
NULLISH: "??"

_NL: /(\r?\n[ \t]*)+/  // Auto-generated from docs/shakar-design-notes.md

COMMENT: "#" /[^\n\r]*/

RAW_HASH_STRING.2: /raw#"(?:[^"]|"(?!#))*"#/
RAW_STRING.2: /raw"(?:\\.|[^"\\])*"/ | /raw'(?:\\.|[^'\\])*'/
SHELL_STRING.2: /sh"(?:\\.|[^"\\])*"/ | /sh'(?:\\.|[^'\\])*'/
STRING: /"(?:\\.|[^"\\])*"/ | /'(?:\\.|[^'\\])*'/
%import common.INT   -> INT
%import common.WS_INLINE
%ignore WS_INLINE
%ignore COMMENT

%import common.NUMBER -> NUMBER

%declare AND OR IS IN NOT FOR IF ELIF ELSE WHILE AWAIT USING OVER HOOK RETURN DEFER ASSERT DBG GET SET FN BREAK CONTINUE THROW DECORATOR DECORATE

%import common.CNAME -> IDENT

//%declare NEWLINE INDENT DEDENT

NEWLINE: /_SHK_NL_/
INDENT: /_SHK_IND_/
DEDENT: /_SHK_DED_/

DEEPMERGE: "+>"
CARET: "^"
POWEQ: "**="
POW : "**"
STAREQ: "*="
STAR: "*"
FLOORDIVEQ: "//="
FLOORDIV: "//"
SLASHEQ: "/="
SLASH: "/"
PLUSEQ: "+="
PLUS: "+"
MINUSEQ: "-="
MINUS: "-"
MODEQ: "%="
MOD: "%"
NEG: "!"

# comparison tokens
EQ: "=="
NEQ: "!="
LT: "<"
LTE: "<="
GT: ">"
GTE: ">="

expr: catchbase
    | catchexpr
catchexpr: catchbase catchhead expr

?catchbase: anonymous_fn
          | anonymous_fn_auto
          | ternaryexpr

catchhead: ("catch" | "@@") catchtail? ":"
catchtail: catchtyped | catchbinder_simple
catchtyped: catchtypes catchbinder_kw?
catchbinder_simple: IDENT
catchbinder_kw: "bind" IDENT
catchtypes: "(" IDENT ("," IDENT)* ")"
ternaryexpr: orexpr ( "?" expr ":" ternaryexpr )?
orexpr: andexpr ( OR andexpr )*
andexpr: bindexpr ( AND bindexpr )*
bindexpr: walrusexpr | lvalue APPLYASSIGN bindexpr
walrus_rhs: expr | catchexpr
walrusexpr: nullishexpr | IDENT ":=" walrus_rhs

nullishexpr: compareexpr ( NULLISH compareexpr )*
compareexpr: addexpr ccc_trailer?
?ccc_trailer: cmpop addexpr ccc_chain?
?ccc_chain: "," ccc_leg ("," ccc_leg)*
?ccc_leg: ccc_or_leg | ccc_and_leg
?ccc_or_leg: OR cmpop addexpr
?ccc_and_leg: AND? ccc_and_payload
?ccc_and_payload: cmpop addexpr | addexpr
cmpop: EQ | NEQ | LT | LTE | GT | GTE
     | IS NOT        // is not
     | NEG IS        // !is
     | NOT IN        // not in
     | IS            // is
     | IN            // in
     | NEG IN        // !in

addexpr: mulexpr ( addop mulexpr )*
addop: DEEPMERGE | CARET | PLUS | MINUS
powexpr: unaryexpr ( POW powexpr )?
mulexpr: powexpr ( mulop powexpr )*
mulop: STAR | SLASH | FLOORDIV | MOD
unaryexpr: await_value
         | "$" unaryexpr -> no_anchor
         | unaryprefixop unaryexpr
         | postfixexpr

unaryprefixop: "-" | NOT | "!" | "~" | "++" | "--"

postfixexpr: primary chain_suffix -> explicit_chain
           | imphead chain_suffix -> implicit_chain
           | DOT -> subject
?chain_suffix: chain_steps chain_incr?
?chain_steps: postfix*
?chain_incr: postfixincr
postfix_field: DOT (IDENT | OVER) -> field
postfix_index: LSQB selectorlist ("," "default" ":" expr)? RSQB -> index
postfix_call:  "(" arglistnamedmixed? ")" -> call
imphead: "." IDENT -> field
       | "." OVER  -> field
       | "." "(" arglist? ")"
       | "." LSQB selectorlist ("," "default" ":" expr)? RSQB -> index
?postfix: postfix_field | postfix_index | postfix_call | postfix_lam1 | postfix_lamn | fieldfan | valuefan
postfixincr: "++" -> incr | "--" -> decr

array: LSQB _NL* [ expr (_NL* "," _NL* expr)* _NL* ("," _NL*)? ] RSQB -> array

selectorlist: selector ("," selector)*
selector: indexsel | slicesel
indexsel: expr
slicesel: slicearm ":" slicearm ( ":" slicearm )?
slicearm: expr -> slicearm_expr | -> slicearm_empty
optstop: "<" expr | expr?
primary: rebind_primary
       | IDENT
       | ANY
       | ALL
       | literal
       | object
       | array
       | listcomp | setliteral | setcomp | dictcomp
       | "(" expr ")"            -> group_expr
       | selectorliteral
       | nullsafe
       | ampval1 | ampvaln

NIL: "nil"
TRUE: "true"
FALSE: "false"
ANY: "any"
ALL: "all"

literal: STRING | RAW_STRING | RAW_HASH_STRING | SHELL_STRING | NUMBER | NIL | TRUE | FALSE
selectorliteral: "`" sellist "`"
sellist: selitem ("," selitem)*
selitem: sliceitem | indexitem
sliceitem: selatom? ":" seloptstop (":" selatom)?
seloptstop: "<" selatom | selatom?
indexitem: selatom
lv_index: "[" selectorlist "]"
selatom: interp | IDENT | NUMBER
interp: "{" expr "}"

nullsafe: "??" "(" expr ")"
comment: COMMENT
rebind_primary: "=" IDENT -> rebind_primary
              | "=" "(" rebind_lvalue ")" -> rebind_primary_grouped

rebind_lvalue: IDENT (postfix_field | postfix_index)* (fieldfan)?
deepmergeassign: lvalue "+>=" expr
assignor: lvalue "or=" expr

lvalue: primary ( postfix_field | lv_index )* ( fieldfan )?
fieldlist: IDENT ("," IDENT)*
fieldfan: "." "{" fieldlist "}"
valuefan: "." "{" valuefan_list "}"
valuefan_list: valuefan_item ("," valuefan_item)*
valuefan_item: IDENT
             | identchain

// reuse existing chain pieces: IDENT (postfix)* (calls, fields, indices)
identchain: IDENT postfix+

breakstmt: BREAK
continuestmt: CONTINUE

?basesimplestmt: base_stmt
                  | postfixif
                  | postfixunless

?base_stmt: returnstmt
          | throwstmt
          | assignor
          | compound_assign
          | fnstmt
          | decoratorstmt
          | assignstmt
          | destructure
          | destructure_walrus
          | guardchain
          | onelineguard
          | returnif
          | breakstmt
          | continuestmt
          | dbg
          | assert
          | usingstmt
          | deferstmt
          | hook
          | fanoutblock
          | catchstmt
          | awaitstmt
          | whilestmt
          | ifstmt
          | expr

?simplestmt: basesimplestmt
                  | postfixif
                  | postfixunless

postfixif: base_stmt IF expr
postfixunless: base_stmt "unless" expr

indentblock: _NL INDENT (stmtlist? _NL+)* stmtlist? DEDENT
inlinestmt: simplestmt
stmtlist: stmt (SEMI stmt)* SEMI?
stmt: simplestmt
          | comment | forin | forsubject | formap1 | formap2

ifstmt: IF expr ":" (inlinebody | indentblock) (_NL* elifclause)* (_NL* elseclause)?
elifclause: ELIF expr ":" (inlinebody | indentblock)
elseclause: ELSE ":" (inlinebody | indentblock)
whilestmt: WHILE expr ":" (inlinebody | indentblock)

returnif: "?ret" expr

guardchain: guardhead (_NL* guardor)* (_NL* guardelse)? -> onelineguard
guardhead: expr ":" indentblock -> guardbranch
guardor: ("|" | "||") expr ":" indentblock -> guardbranch
guardelse: ("|:" | "||:") indentblock -> indentblock
onelineguard: AWAIT ( "(" expr ")" | expr ) ":" inlinebody -> awaitstmt
            | guardbranch_inline ("|" guardbranch_inline)* ("|:" inlinebody)?
guardbranch_inline: expr ":" inlinebody -> guardbranch
inlinebody: inlinecall | simplestmt | "{" stmtlist? "}"

!inlinecall: callee "(" arglistnamedmixed? ")"

forin: FOR forin_pattern IN expr ":" (inlinebody | indentblock)
forin_pattern: pattern
             | pattern_list_inline
pattern_list_inline: IDENT ("," IDENT)+
forsubject: FOR expr ":" (inlinebody | indentblock)
forindexed: FOR "[" binderpattern "]" expr ":" (inlinebody | indentblock)
formap1: forindexed
formap2: FOR "[" binderpattern "," binderpattern "]" expr ":" (inlinebody | indentblock)
indexing: postfixexpr "[" selectorlist "]"

callee: postfixexpr
call: callee "(" arglistnamedmixed? ")"
arglist: arg ("," arg)*
arg: expr | holeexpr
arglistnamedmixed: argitem ("," argitem)*
namedarg: IDENT COLON expr
argpos_list: arg ("," arg)*
argnamed_list: namedarg ("," namedarg)*
argitem: namedarg | arg
holeexpr: "?"

// Value-level ampersand lambdas (expressions)
ampval1:  "&" "(" expr ")"                              -> amp_lambda1
ampvaln:  "&" "[" paramlist "]" "(" expr ")"            -> amp_lambdan

postfix_lam1: "&" "(" expr ")" -> lambdacall1
postfix_lamn: "&" "[" paramlist "]" "(" expr ")" -> lambdacalln

paramlist: IDENT ("," IDENT)*
comphead: (OVER | FOR) overspec
overspec: "[" binderlist "]" expr | expr ("bind" pattern)?
binderpattern: "^" IDENT -> hoist | pattern
binderlist: binderpattern ("," binderpattern)*

ifclause: IF expr

listcomp: "[" expr comphead ifclause? "]"
setliteral: "set" "{" "}" -> setliteral_empty
           | "set" "{" expr ("," expr)* (",")? "}" -> setliteral
setcomp: "set" "{" expr comphead ifclause? "}"
dictcomp: "{" expr ":" expr comphead ifclause? "}"

pattern: IDENT | "(" pattern_list ")"
pattern_list: pattern "," pattern ("," pattern)*

!assignstmt: lvalue "=" expr

throwstmt: THROW expr?

destrhs: expr ("," expr)+ -> pack
destructure: pattern_list "=" (destrhs | expr)
destructure_walrus: pattern_list ":=" (destrhs | expr)

!awaitstmt: AWAIT await_body
await_body: "[" "any" "]" "(" anyarmlist optcomma ")" ( ":" (inlinebody | indentblock) )? -> awaitanycall
          | "[" "all" "]" "(" allarmlist optcomma ")" ( ":" (inlinebody | indentblock) )? -> awaitallcall
          | ( "(" expr ")" | expr ) ":" (inlinebody | indentblock) -> awaitstmt
await_value: AWAIT ( "(" expr ")" | expr ) -> await_value
anyarmlist: anyarm ("," anyarm)*
allarmlist: anyarm ("," anyarm)*
anyarm: (IDENT ":")? expr (":" (inlinebody | indentblock))? | "timeout" expr (":" (inlinebody | indentblock))?

optcomma: ","?
!catchstmt: expr "catch" catchtail? ":" (inlinebody | indentblock)

hook: HOOK (STRING | RAW_STRING | RAW_HASH_STRING) ":" (inlinebody | indentblock)

decoratorstmt: DECORATOR IDENT "(" paramlist? ")" ":" (inlinebody | indentblock)
             | DECORATOR IDENT ":" (inlinebody | indentblock)

decoratorlist: decoratorentry+ -> decorator_list
decoratorentry: AT expr _NL+ -> decorator_entry

fnstmt: decoratorlist? FN IDENT "(" paramlist? ")" ":" (inlinebody | indentblock)
anonymous_fn: FN "(" paramlist? ")" ":" (inlinebody | indentblock)
anonymous_fn_auto: FN "(" "(" ")" ")" ":" (inlinebody | indentblock)

compound_assign: lvalue (PLUSEQ | MINUSEQ | STAREQ | SLASHEQ | FLOORDIVEQ | MODEQ | POWEQ) expr
fanoutblock: expr fanblock
fanblock: "{" fanclause (fanclause_sep fanclause)* fanclause_sep? "}"
fanclause_sep: _NL+ | SEMI | ","
fanassignop: "=" -> fanop_assign
          | APPLYASSIGN -> fanop_apply
          | PLUSEQ -> fanop_pluseq
          | MINUSEQ -> fanop_minuseq
          | STAREQ -> fanop_stareq
          | SLASHEQ -> fanop_slasheq
          | FLOORDIVEQ -> fanop_floordiveq
          | MODEQ -> fanop_modeq
          | POWEQ -> fanop_poweq
fanclause: DOT fanpath fanassignop expr
fanpath: fanseg+
fanseg: IDENT -> field
      | "[" selectorlist "]" -> lv_index

// SINGLE-TOKEN separators
obj_sep: COMMA | SEMI | _NL | INDENT | DEDENT

// Record literal as an expression
object: LBRACE object_items? RBRACE

object_items: obj_sep* object_item (obj_sep* object_item)* obj_sep*

// Items: field / getter / setter; inline expr or indentblock body
object_item: (IDENT | OVER) ":" (obj_body | (_NL* expr))                           -> obj_field_ident
           | (STRING | RAW_STRING | RAW_HASH_STRING) ":" (obj_body | (_NL* expr)) -> obj_field_string
           | keyexpr ":" (obj_body | (_NL* expr))                                 -> obj_field_expr
           | GET IDENT ("(" ")")? ":" (obj_body | (_NL* expr))                    -> obj_get
           | SET IDENT "(" IDENT ")" ":" (obj_body | (_NL* expr))                 -> obj_set
           | (IDENT | OVER) "(" paramlist? ")" ":" (obj_body | (_NL* expr))        -> obj_method

obj_body: obj_block_body
        | inlinebody -> indentblock

obj_block_body: _NL INDENT (stmtlist? _NL+)* stmtlist? DEDENT -> indentblock

keyexpr: compareexpr

!returnstmt: RETURN (destrhs | expr)?

!deferstmt: DEFER (simplecall deferafter? | deferlabel? deferafter? deferbody)
deferlabel: IDENT
deferbody: ":" inlinebody -> defer_block
         | ":" indentblock -> defer_block
deferafter: "after" (IDENT | "(" (IDENT ("," IDENT)*)? ")")

simplecall: callee "(" arglistnamedmixed? ")"

!usingstmt: USING ("[" IDENT "]")? expr ("bind" IDENT)? ":" (inlinebody | indentblock)

assert: ASSERT expr ("," expr)?

dbg: DBG (expr ("," expr)?)
