//start: (comment | stmtlist | NEWLINE | _NL)*

start_noindent: stmtlist (_NL+ stmtlist)* _NL*
start_indented: stmtlist (_NL+ stmtlist)* _NL*
//start_indented: stmtlist (NEWLINE+ stmtlist)* NEWLINE*

RBRACE: "}"
LBRACE: "{"
RSQB: "]"
LSQB: "["
RPAR: ")"
LPAR: "("
DOT: "."
COMMA: ","
SEMI: ";"
COLON: ":"

AT: "@"

WALRUS: ":="
APPLYASSIGN: ".="

QMARK: "?"
NULLISH: "??"

_NL: /(\r?\n[ \t]*)+/  // Auto-generated from docs/shakar-design-notes.md

COMMENT: "#" /[^\n\r]*/

STRING: /"(?:\\.|[^"\\])*"/ | /'(?:\\.|[^'\\])*'/
%import common.INT   -> INT
%import common.WS_INLINE
%ignore WS_INLINE

%import common.NUMBER -> NUMBER

%declare AND OR IS IN NOT FOR IF ELIF ELSE AWAIT ANY USING OVER ALL HOOK RETURN DEFER ASSERT DBG GET SET FN BREAK CONTINUE THROW DECORATOR DECORATE

%import common.CNAME -> IDENT

//%declare NEWLINE INDENT DEDENT

NEWLINE: /_SHK_NL_/
INDENT: /_SHK_IND_/
DEDENT: /_SHK_DED_/

DEEPMERGE: "+>"
CARET: "^"
POWEQ: "**="
POW : "**"
STAREQ: "*="
STAR: "*"
FLOORDIVEQ: "//="
FLOORDIV: "//"
SLASHEQ: "/="
SLASH: "/"
PLUSEQ: "+="
PLUS: "+"
MINUSEQ: "-="
MINUS: "-"
MODEQ: "%="
MOD: "%"
NEG: "!"

# comparison tokens
EQ: "=="
NEQ: "!="
LT: "<"
LTE: "<="
GT: ">"
GTE: ">="

expr: catchbase
    | catchbase catchhead expr -> catchexpr

?catchbase: anonymous_fn
          | anonymous_fn_auto
          | ternaryexpr

catchhead: ("catch" | "@@") catchtail? ":"
catchtail: catchtyped | catchbinder_simple
catchtyped: catchtypes catchbinder_kw?
catchbinder_simple: IDENT
catchbinder_kw: "bind" IDENT
catchtypes: "(" IDENT ("," IDENT)* ")"
ternaryexpr: orexpr ( "?" expr ":" ternaryexpr )?
orexpr: andexpr ( OR andexpr )*
andexpr: bindexpr ( AND bindexpr )*
bindexpr: walrusexpr | lvalue APPLYASSIGN bindexpr
walrusexpr: nullishexpr | IDENT ":=" expr_nc

nullishexpr: compareexpr ( NULLISH compareexpr )*
compareexpr: addexpr ccc_trailer?
?ccc_trailer: cmpop addexpr ccc_chain?
?ccc_chain: "," ccc_leg ("," ccc_leg)*
?ccc_leg: ccc_or_leg | ccc_and_leg
?ccc_or_leg: OR cmpop addexpr
?ccc_and_leg: AND? ccc_and_payload
?ccc_and_payload: cmpop addexpr | addexpr
cmpop: EQ | NEQ | LT | LTE | GT | GTE
     | IS NOT        // is not
     | NEG IS        // !is
     | NOT IN        // not in
     | IS            // is
     | IN            // in
     | NEG IN        // !in

# ===== No-Comma (NC) expressions: forbid top-level CCC at select sites =====
expr_nc: catchbase_nc
       | catchbase_nc catchhead expr_nc -> catchexpr

?catchbase_nc: anonymous_fn
             | anonymous_fn_auto
             | ternaryexpr_nc
ternaryexpr_nc: orexpr_nc ( "?" expr ":" ternaryexpr_nc )?
orexpr_nc: andexpr_nc ( OR andexpr_nc )*
andexpr_nc: bindexpr_nc ( AND bindexpr_nc )*
bindexpr_nc: walrusexpr_nc | lvalue ".=" bindexpr_nc
walrusexpr_nc: nullishexpr_nc | IDENT ":=" expr_nc
nullishexpr_nc: compareexpr_nc ( "??" compareexpr_nc )*
compareexpr_nc: addexpr ( cmpop addexpr )*

addexpr: mulexpr ( addop mulexpr )*
addop: DEEPMERGE | CARET | PLUS | MINUS
powexpr: unaryexpr ( POW powexpr )?
mulexpr: powexpr ( mulop powexpr )*
mulop: STAR | SLASH | FLOORDIV | MOD
unaryexpr: await_value
         | "$" unaryexpr -> no_anchor
         | unaryprefixop unaryexpr
         | postfixexpr

unaryprefixop: "-" | NOT | "!" | "~" | "++" | "--"

postfixexpr: primary chain_suffix -> explicit_chain
           | imphead chain_suffix -> implicit_chain
           | DOT -> subject
?chain_suffix: chain_steps chain_incr?
?chain_steps: postfix*
?chain_incr: postfixincr
postfix_field: DOT IDENT -> field
postfix_index: LSQB selectorlist ("," "default" ":" expr)? RSQB -> index
postfix_call:  "(" arglistnamedmixed? ")" -> call
imphead: "." IDENT -> field
       | "." "(" arglist? ")"
       | "." LSQB selectorlist ("," "default" ":" expr)? RSQB -> index
?postfix: postfix_field | postfix_index | postfix_call | postfix_lam1 | postfix_lamn | fieldfan
postfixincr: "++" -> incr | "--" -> decr

array: LSQB _NL* [ expr (_NL* "," _NL* expr)* _NL* ("," _NL*)? ] RSQB -> array

selectorlist: selector ("," selector)*
selector: indexsel | slicesel
indexsel: expr
slicesel: slicearm ":" slicearm ( ":" slicearm )?
slicearm: expr -> slicearm_expr | -> slicearm_empty
optstop: "<" expr | expr?
primary: rebind_primary
       | IDENT
       | literal
       | object
       | array
       | listcomp | setliteral | setcomp | dictcomp
       | "(" expr ")"            -> group_expr
       | selectorliteral
       | nullsafe
       | ampval1 | ampvaln

NIL: "nil"
TRUE: "true"
FALSE: "false"

literal: STRING | NUMBER | NIL | TRUE | FALSE
selectorliteral: "`" sellist "`"
sellist: selitem ("," selitem)*
selitem: sliceitem | indexitem
sliceitem: selatom? ":" seloptstop (":" selatom)?
seloptstop: "<" selatom | selatom?
indexitem: selatom
lv_index: "[" selectorlist "]"
selatom: interp | IDENT | NUMBER
interp: "{" expr "}"

nullsafe: "??" "(" expr ")"
comment: COMMENT
rebind_primary: "=" IDENT -> rebind_primary
              | "=" "(" rebind_lvalue ")" -> rebind_primary_grouped

rebind_lvalue: IDENT (postfix_field | postfix_index)* (fieldfan)?
deepmergeassign: lvalue "+>=" expr
assignor: lvalue "or=" expr

lvalue: primary ( postfix_field | lv_index )* ( fieldfan )?
fieldlist: IDENT ("," IDENT)*
fieldfan: "." "{" fieldlist "}"

breakstmt: BREAK
continuestmt: CONTINUE

?basesimplestmt: base_stmt
                  | postfixif
                  | postfixunless

?base_stmt: returnstmt
          | throwstmt
          | assignor
          | compound_assign
          | fnstmt
          | decoratorstmt
          | assignstmt
          | destructure
          | destructure_walrus
          | onelineguard
          | returnif
          | breakstmt
          | continuestmt
          | dbg
          | assert
          | usingstmt
          | deferstmt
          | hook
          | catchstmt
          | awaitstmt
          | awaitanycall
          | awaitallcall
          | ifstmt
          | expr

?simplestmt: basesimplestmt
                  | postfixif
                  | postfixunless

postfixif: base_stmt IF expr
postfixunless: base_stmt "unless" expr

indentblock: _NL INDENT (stmtlist? _NL+)* stmtlist? DEDENT
inlinestmt: simplestmt
stmtlist: stmt (SEMI stmt)* SEMI?
stmt: simplestmt
          | comment | forin | forsubject | formap1 | formap2

ifstmt: IF expr ":" (inlinebody | indentblock) (_NL* elifclause)* (_NL* elseclause)?
elifclause: ELIF expr ":" (inlinebody | indentblock)
elseclause: ELSE ":" (inlinebody | indentblock)

returnif: "?ret" expr

guardchain: guardhead guardor* guardelse?
guardhead: expr ":" indentblock
guardor: ("|" | "||") expr ":" indentblock
guardelse: ("|:" | "||:") indentblock
onelineguard: AWAIT ( "(" expr ")" | expr ) ":" inlinebody -> awaitstmt
            | guardbranch ("|" guardbranch)* ("|:" inlinebody)?
guardbranch: expr ":" inlinebody
inlinebody: inlinecall | simplestmt | "{" stmtlist? "}"

!inlinecall: callee "(" arglistnamedmixed? ")"

forin: FOR forin_pattern IN expr ":" (inlinebody | indentblock)
forin_pattern: pattern
             | pattern_list_inline
pattern_list_inline: IDENT ("," IDENT)+
forsubject: FOR expr ":" (inlinebody | indentblock)
forindexed: FOR "[" binderpattern "]" expr ":" (inlinebody | indentblock)
formap1: forindexed
formap2: FOR "[" binderpattern "," binderpattern "]" expr ":" (inlinebody | indentblock)
indexing: postfixexpr "[" selectorlist "]"

callee: postfixexpr
call: callee "(" arglistnamedmixed? ")"
arglist: arg ("," arg)*
arg: expr | holeexpr
arglistnamedmixed: argitem ("," argitem)*
namedarg: IDENT COLON expr
argpos_list: arg ("," arg)*
argnamed_list: namedarg ("," namedarg)*
argitem: namedarg | arg
holeexpr: "?"

// Value-level ampersand lambdas (expressions)
ampval1:  "&" "(" expr ")"                              -> amp_lambda1
ampvaln:  "&" "[" paramlist "]" "(" expr ")"            -> amp_lambdan

postfix_lam1: "&" "(" expr ")" -> lambdacall1
postfix_lamn: "&" "[" paramlist "]" "(" expr ")" -> lambdacalln

paramlist: IDENT ("," IDENT)*
comphead: (OVER | FOR) overspec
overspec: "[" binderlist "]" expr | expr ("bind" pattern)?
binderpattern: "^" IDENT -> hoist | pattern
binderlist: binderpattern ("," binderpattern)*

ifclause: IF expr

listcomp: "[" expr comphead ifclause? "]"
setliteral: "set" "{" "}" -> setliteral_empty
           | "set" "{" expr ("," expr)* (",")? "}" -> setliteral
setcomp: "set" "{" expr comphead ifclause? "}"
dictcomp: "{" expr ":" expr comphead ifclause? "}"

pattern: IDENT | "(" pattern_list ")"
pattern_list: pattern "," pattern ("," pattern)*

!assignstmt: lvalue "=" expr_nc

throwstmt: THROW expr?

destrhs: expr ("," expr)+ -> pack
destructure: pattern_list "=" (destrhs | expr)
destructure_walrus: pattern_list ":=" (destrhs | expr)

!awaitstmt: AWAIT ( "(" expr ")" | expr ) ":" (inlinebody | indentblock)
await_value: AWAIT ( "(" expr ")" | expr ) -> await_value
!awaitanycall: AWAIT "[" ANY "]" "(" anyarmlist optcomma ")" ( ":" (inlinebody | indentblock) )?
!awaitallcall: AWAIT "[" ALL "]" "(" allarmlist optcomma ")" ( ":" (inlinebody | indentblock) )?
anyarmlist: anyarm ("," anyarm)*
allarmlist: anyarm ("," anyarm)*
anyarm: (IDENT ":")? expr (":" (inlinebody | indentblock))? | "timeout" expr (":" (inlinebody | indentblock))?

optcomma: ","?
!catchstmt: expr "catch" catchtail? ":" (inlinebody | indentblock)

hook: HOOK STRING ":" (inlinebody | indentblock)

decoratorstmt: DECORATOR IDENT "(" paramlist? ")" ":" (inlinebody | indentblock)
             | DECORATOR IDENT ":" (inlinebody | indentblock)

decoratorlist: decoratorentry+ -> decorator_list
decoratorentry: AT expr _NL+ -> decorator_entry

fnstmt: decoratorlist? FN IDENT "(" paramlist? ")" ":" (inlinebody | indentblock)
anonymous_fn: FN "(" paramlist? ")" ":" (inlinebody | indentblock)
anonymous_fn_auto: FN "(" "(" ")" ")" ":" (inlinebody | indentblock)

compound_assign: lvalue (PLUSEQ | MINUSEQ | STAREQ | SLASHEQ | FLOORDIVEQ | MODEQ | POWEQ) expr_nc

// SINGLE-TOKEN separators
obj_sep: COMMA | SEMI | _NL | INDENT | DEDENT

// Record literal as an expression
object: LBRACE object_items? RBRACE

object_items: obj_sep* object_item (obj_sep* object_item)* obj_sep*

// Items: field / getter / setter; inline expr or indentblock body
object_item: IDENT ":" (obj_body | (_NL* expr))            -> obj_field_ident
           | STRING ":" (obj_body | (_NL* expr))           -> obj_field_string
           | keyexpr ":" (obj_body | (_NL* expr))          -> obj_field_expr
          | GET IDENT ("(" ")")? ":" (obj_body | (_NL* expr))    -> obj_get
          | SET IDENT "(" IDENT ")" ":" (obj_body | (_NL* expr)) -> obj_set
          | IDENT "(" paramlist? ")" ":" (obj_body | (_NL* expr)) -> obj_method

obj_body: obj_block_body
        | inlinebody -> indentblock

obj_block_body: _NL INDENT (stmtlist? _NL+)* stmtlist? DEDENT -> indentblock

keyexpr: compareexpr_nc

!returnstmt: RETURN expr?

!deferstmt: DEFER (simplecall deferafter? | deferlabel? deferafter? deferbody)
deferlabel: IDENT
deferbody: ":" inlinebody -> defer_block
         | ":" indentblock -> defer_block
deferafter: "after" (IDENT | "(" (IDENT ("," IDENT)*)? ")")

simplecall: callee "(" arglistnamedmixed? ")"

!usingstmt: USING ("[" IDENT "]")? expr ("bind" IDENT)? ":" indentblock

assert: ASSERT expr ("," expr)?

dbg: DBG (expr ("," expr)?)
